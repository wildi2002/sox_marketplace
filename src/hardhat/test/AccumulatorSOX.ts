import { ethers } from "hardhat";
import { expect } from "chai";
import { TestAccumulatorVerifier } from "../typechain-types";
import {
    initSync,
    acc_js,
    prove_js,
    prove_ext_js,
} from "../../app/lib/crypto_lib";
import { readFile } from "node:fs/promises";
import { randomBytes } from "node:crypto";

function generateRandomUint8Arrays(count: number): Uint8Array[] {
    const randomUint8Arrays: Uint8Array[] = [];

    for (let i = 0; i < count; i++) {
        // Generate a random size between 1 and 1023
        const size = Math.floor(Math.random() * 1024) + 1;
        randomUint8Arrays.push(randomBytes(size));
    }

    return randomUint8Arrays;
}

function pickRandomIndices<T>(array: T[]): [number[], T[]] {
    if (array.length === 0) {
        return [[], []]; // Return empty arrays if the input array is empty
    }

    // Generate a random count of indices between 1 and the length of the array
    const count = Math.floor(Math.random() * array.length) + 1;

    // Create a set to store unique random indices
    const indicesSet = new Set<number>();

    // Generate unique random indices
    while (indicesSet.size < count) {
        const randomIndex = Math.floor(Math.random() * array.length);
        indicesSet.add(randomIndex);
    }

    // Convert the set to an array and sort it
    const indicesArray = Array.from(indicesSet).sort((a, b) => a - b);

    // Create an array for the corresponding elements
    const elementsArray = indicesArray.map((index) => array[index]);

    return [indicesArray, elementsArray];
}

before(async () => {
    const module = await readFile(
        "../../app/lib/crypto_lib/crypto_lib_bg.wasm"
    );
    initSync({ module: module });
});

describe("AccumulatorVerifier", () => {
    let verifier: TestAccumulatorVerifier;

    beforeEach(async () => {
        const AccVerifFac = await ethers.getContractFactory(
            "AccumulatorVerifier"
        );
        const realAcc = await AccVerifFac.deploy();
        await realAcc.waitForDeployment();

        const TestAccumulatorVerifierFactory = await ethers.getContractFactory(
            "TestAccumulatorVerifier",
            {
                libraries: {
                    AccumulatorVerifier: await realAcc.getAddress(),
                },
            }
        );
        verifier =
            (await TestAccumulatorVerifierFactory.deploy()) as TestAccumulatorVerifier;
        await verifier.waitForDeployment();
    });

    describe("verify", () => {
        it("returns true for a simple valid Merkle proof", async () => {
            const l1 = ethers.keccak256("0xdead");
            const l2 = ethers.keccak256("0xbeef");
            const root = ethers.keccak256(ethers.concat([l1, l2]));

            const indices = [0];
            const values = [l1];
            const proof = [[l2]];

            const result = await verifier.verify(root, indices, values, proof);
            expect(result).to.equal(true);
        });

        it("returns false for an simple invalid Merkle proof", async () => {
            const l1 = ethers.keccak256("0xdead");
            const l2 = ethers.keccak256("0xbeef");
            const badRoot = ethers.keccak256("0xbee5");

            const indices = [0];
            const values = [l1];
            const proof = [[l2]];

            const result = await verifier.verify(
                badRoot,
                indices,
                values,
                proof
            );
            expect(result).to.equal(false);
        });

        it("returns true for a proof generated by the wasm library on random data", async () => {
            for (let i = 0; i < 10; ++i) {
                const values = generateRandomUint8Arrays(256);
                const valuesKeccak = values.map((v) => ethers.keccak256(v));
                const [indices, pickedValues] = pickRandomIndices(valuesKeccak);

                const root = acc_js(values);
                const proof = prove_js(values, indices);

                const result = await verifier.verify(
                    root,
                    indices,
                    pickedValues,
                    proof
                );

                expect(result).to.equal(true);
            }
        });
    });

    describe("verifyExt", () => {
        it("returns true for a valid extension proof", async () => {
            const newLeaf = ethers.keccak256(ethers.toUtf8Bytes("new"));
            const oldRoot = ethers.keccak256(ethers.toUtf8Bytes("base"));
            const newRoot = ethers.keccak256(ethers.concat([newLeaf, oldRoot]));
            const proof = [[oldRoot]];
            const result = await verifier.verifyExt(
                0,
                oldRoot,
                newRoot,
                newLeaf,
                proof
            );
            expect(result).to.equal(true);
        });

        it("returns false for an invalid extension proof", async () => {
            const newLeaf = ethers.keccak256(ethers.toUtf8Bytes("new"));
            const oldRoot = ethers.keccak256(ethers.toUtf8Bytes("base"));
            const fakeRoot = ethers.keccak256(ethers.toUtf8Bytes("fake"));
            const proof = [[fakeRoot]];
            const result = await verifier.verifyExt(
                0,
                oldRoot,
                fakeRoot,
                newLeaf,
                proof
            );
            expect(result).to.equal(false);
        });

        it("returns true for an extension proof generated by the wasm library on random data", async () => {
            for (let i = 0; i < 100; ++i) {
                const values = generateRandomUint8Arrays(256);
                const prevRoot = acc_js(values);
                const newVal = generateRandomUint8Arrays(1)[0];
                values.push(newVal);
                const currRoot = acc_js(values);

                const proof = prove_ext_js(values);

                const result = await verifier.verifyExt(
                    values.length - 1,
                    prevRoot,
                    currRoot,
                    ethers.keccak256(newVal),
                    proof
                );

                expect(result).to.equal(true);
            }
        });
    });
});
