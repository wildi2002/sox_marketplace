import { expect } from "chai";
import hre from "hardhat";
import { ethers } from "hardhat";
import "@nomicfoundation/hardhat-chai-matchers";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import { parseEther, ZeroHash } from "ethers";
import { readFile } from "node:fs/promises";
import { join } from "node:path";
import EntryPointArtifact from "@account-abstraction/contracts/artifacts/EntryPoint.json";
import {
    bytes_to_hex,
    compute_precontract_values_v2,
    compute_proofs_v2,
    compute_proofs_left_v2,
    compute_proof_right_v2,
    evaluate_circuit_v2_wasm,
    hpre_v2,
    initSync,
} from "../../app/lib/crypto_lib/crypto_lib";

/**
 * Proof Verification Tests
 * 
 * This test suite verifies that:
 * 1. Proofs are correctly generated by WASM functions (compute_proofs_v2, compute_proofs_left_v2, compute_proof_right_v2)
 * 2. Proofs are correctly verified by the DisputeSOXAccount contract
 * 3. All three scenarios work: submitCommitment (8a), submitCommitmentLeft (8b), submitCommitmentRight (8c)
 * 
 * This ensures end-to-end correctness of the proof generation and verification pipeline.
 */

describe("Proof Verification Tests (V2)", function () {
    let sponsor: HardhatEthersSigner;
    let buyer: HardhatEthersSigner;
    let vendor: HardhatEthersSigner;
    let buyerDisputeSponsor: HardhatEthersSigner;
    let vendorDisputeSponsor: HardhatEthersSigner;
    
    let entryPoint: any;
    let optimisticAccount: any;
    let disputeAccount: any;
    
    // Test parameters - Using small file for fast testing
    const FILE_SIZE_BYTES = 1024 * 16; // 16KB file
    let numBlocks: number;
    let numGates: number;
    
    const agreedPrice = parseEther("1.0");
    const completionTip = parseEther("0.1");
    const disputeTip = parseEther("0.12");
    const timeoutIncrement = 3600n;
    
    const SPONSOR_FEES = 5n;
    const DISPUTE_FEES = 10n;
    
    // Circuit data
    let circuit_bytes: Uint8Array;
    let evaluated_bytes: Uint8Array;
    let ct: Uint8Array;
    let commitment: { c: string; o: string };
    let key: Uint8Array;
    let description: string;
    
    before(async function () {
        [sponsor, buyer, vendor, buyerDisputeSponsor, vendorDisputeSponsor] = await ethers.getSigners();
        
        console.log("\nüîç ===== PROOF VERIFICATION TESTS =====");
        
        // Initialize WASM module
        const modulePath = join(__dirname, "../../app/lib/crypto_lib/crypto_lib_bg.wasm");
        const module = await readFile(modulePath);
        initSync({ module: module });
        console.log("‚úÖ WASM module initialized");
        
        // Generate real file and V2 circuit
        console.log("üìù Generating V2 circuit...");
        const file = new Uint8Array(FILE_SIZE_BYTES);
        // Fill with some data for realism
        for (let i = 0; i < file.length; i++) {
            file[i] = (i % 256);
        }
        key = new Uint8Array(16);
        // Fill key with some data
        for (let i = 0; i < key.length; i++) {
            key[i] = (i * 17) % 256;
        }
        
        const precontract = compute_precontract_values_v2(file, key);
        circuit_bytes = precontract.circuit_bytes;
        ct = precontract.ct;
        commitment = precontract.commitment;
        description = precontract.description;
        numBlocks = precontract.num_blocks;
        numGates = precontract.num_gates;
        
        console.log(`   numBlocks: ${numBlocks}`);
        console.log(`   numGates: ${numGates}`);
        
        // Evaluate V2 circuit
        evaluated_bytes = evaluate_circuit_v2_wasm(
            circuit_bytes,
            ct,
            bytes_to_hex(key)
        ).to_bytes();
        
        console.log("‚úÖ Circuit generated and evaluated\n");
        
        // Deploy EntryPoint
        const EntryPointFactory = new ethers.ContractFactory(
            EntryPointArtifact.abi,
            EntryPointArtifact.bytecode,
            sponsor
        );
        entryPoint = await EntryPointFactory.deploy();
        await entryPoint.waitForDeployment();
        
        // Deploy libraries
        const AccumulatorVerifierFactory = await ethers.getContractFactory("AccumulatorVerifier");
        const accumulatorVerifier = await AccumulatorVerifierFactory.deploy();
        await accumulatorVerifier.waitForDeployment();
        
        const CommitmentOpenerFactory = await ethers.getContractFactory("CommitmentOpener");
        const commitmentOpener = await CommitmentOpenerFactory.deploy();
        await commitmentOpener.waitForDeployment();
        
        const SHA256EvaluatorFactory = await ethers.getContractFactory("SHA256Evaluator");
        const sha256Evaluator = await SHA256EvaluatorFactory.deploy();
        await sha256Evaluator.waitForDeployment();
        
        const DisputeDeployerFactory = await ethers.getContractFactory("DisputeDeployer", {
            libraries: {
                AccumulatorVerifier: await accumulatorVerifier.getAddress(),
                CommitmentOpener: await commitmentOpener.getAddress(),
                SHA256Evaluator: await sha256Evaluator.getAddress(),
            },
        });
        const disputeDeployer = await DisputeDeployerFactory.deploy();
        await disputeDeployer.waitForDeployment();
        
        const OptimisticSOXAccountFactory = await ethers.getContractFactory("OptimisticSOXAccount", {
            libraries: {
                DisputeDeployer: await disputeDeployer.getAddress(),
            },
        });
        optimisticAccount = await OptimisticSOXAccountFactory.connect(sponsor).deploy(
            await entryPoint.getAddress(),
            await vendor.getAddress(),
            await buyer.getAddress(),
            agreedPrice,
            completionTip,
            disputeTip,
            timeoutIncrement,
            commitment.c,
            numBlocks,
            numGates,
            await vendor.getAddress(),
            { value: SPONSOR_FEES }
        );
        await optimisticAccount.waitForDeployment();
        
        // Setup optimistic phase
        await optimisticAccount.connect(buyer).sendPayment({ value: agreedPrice + completionTip });
        await optimisticAccount.connect(vendor).sendKey(key);
        await optimisticAccount.connect(buyerDisputeSponsor).sendBuyerDisputeSponsorFee({
            value: DISPUTE_FEES + disputeTip
        });
        await optimisticAccount.connect(vendorDisputeSponsor).sendVendorDisputeSponsorFee({
            value: DISPUTE_FEES + disputeTip + agreedPrice
        });
        
        const disputeAddress = await optimisticAccount.disputeContract();
        disputeAccount = await ethers.getContractAt("DisputeSOXAccount", disputeAddress);
        
        console.log("‚úÖ Contracts deployed and optimistic phase completed\n");
    });
    
    // Helper function to deploy a fresh dispute contract for each scenario
    async function deployFreshDispute(): Promise<{ optimisticAccount: any; disputeAccount: any }> {
        const AccumulatorVerifierFactory = await ethers.getContractFactory("AccumulatorVerifier");
        const accumulatorVerifier = await AccumulatorVerifierFactory.deploy();
        await accumulatorVerifier.waitForDeployment();
        
        const CommitmentOpenerFactory = await ethers.getContractFactory("CommitmentOpener");
        const commitmentOpener = await CommitmentOpenerFactory.deploy();
        await commitmentOpener.waitForDeployment();
        
        const SHA256EvaluatorFactory = await ethers.getContractFactory("SHA256Evaluator");
        const sha256Evaluator = await SHA256EvaluatorFactory.deploy();
        await sha256Evaluator.waitForDeployment();
        
        const DisputeDeployerFactory = await ethers.getContractFactory("DisputeDeployer", {
            libraries: {
                AccumulatorVerifier: await accumulatorVerifier.getAddress(),
                CommitmentOpener: await commitmentOpener.getAddress(),
                SHA256Evaluator: await sha256Evaluator.getAddress(),
            },
        });
        const disputeDeployer = await DisputeDeployerFactory.deploy();
        await disputeDeployer.waitForDeployment();
        
        const OptimisticSOXAccountFactory = await ethers.getContractFactory("OptimisticSOXAccount", {
            libraries: {
                DisputeDeployer: await disputeDeployer.getAddress(),
            },
        });
        const freshOptimisticAccount = await OptimisticSOXAccountFactory.connect(sponsor).deploy(
            await entryPoint.getAddress(),
            await vendor.getAddress(),
            await buyer.getAddress(),
            agreedPrice,
            completionTip,
            disputeTip,
            timeoutIncrement,
            commitment.c,
            numBlocks,
            numGates,
            await vendor.getAddress(),
            { value: SPONSOR_FEES }
        );
        await freshOptimisticAccount.waitForDeployment();
        
        // Setup optimistic phase
        await freshOptimisticAccount.connect(buyer).sendPayment({ value: agreedPrice + completionTip });
        await freshOptimisticAccount.connect(vendor).sendKey(key);
        // Buyer does NOT call completeTransaction() - this triggers dispute
        await freshOptimisticAccount.connect(buyerDisputeSponsor).sendBuyerDisputeSponsorFee({
            value: DISPUTE_FEES + disputeTip
        });
        await freshOptimisticAccount.connect(vendorDisputeSponsor).sendVendorDisputeSponsorFee({
            value: DISPUTE_FEES + disputeTip + agreedPrice
        });
        
        const disputeAddress = await freshOptimisticAccount.disputeContract();
        const freshDisputeAccount = await ethers.getContractAt("DisputeSOXAccount", disputeAddress);
        
        return { optimisticAccount: freshOptimisticAccount, disputeAccount: freshDisputeAccount };
    }
    
    describe("Scenario 1: submitCommitment (Step 8a) - Middle Gate", function () {
        it("Should generate correct proofs and verify them in submitCommitment", async function () {
            console.log("\nüìä Scenario 1: submitCommitment (State 2)");
            
            // Navigate to state 2 (WaitVendorData) by going through challenge-response
            // We need to find a disagreement point in the middle
            let state = Number(await disputeAccount.currState());
            const maxRounds = Math.ceil(Math.log2(numGates)) + 5; // Safety limit
            let roundCount = 0;
            
            // Navigate to WaitVendorData state
            while (state === 0 && roundCount < maxRounds) { // State 0 = ChallengeBuyer
                const challenge = await disputeAccount.chall();
                console.log(`   Round ${roundCount + 1}: challenge = ${challenge} (1-indexed)`);
                
                // Buyer responds with wrong hpre (ZeroHash) to force disagreement
                await disputeAccount.connect(buyer).respondChallenge(ZeroHash);
                
                // Vendor disagrees once to narrow down
                if (roundCount === 0) {
                    await disputeAccount.connect(vendor).giveOpinion(false);
                } else {
                    // Then vendor agrees to move towards WaitVendorData
                    await disputeAccount.connect(vendor).giveOpinion(true);
                }
                
                state = Number(await disputeAccount.currState());
                roundCount++;
                
                if (state === 2) { // WaitVendorData
                    break;
                }
            }
            
            expect(state).to.equal(2, "Should be in WaitVendorData state (2)");
            console.log(`   ‚úÖ Reached WaitVendorData state after ${roundCount} rounds`);
            
            const gateNum = Number(await disputeAccount.a());
            console.log(`   Gate number (challenge): ${gateNum} (1-indexed)`);
            
            // Verify gateNum is in valid range for Step 8a: 1 < gateNum < numGates + 1
            expect(gateNum).to.be.greaterThan(1);
            expect(gateNum).to.be.lessThan(numGates + 1);
            
            // Generate proofs using WASM
            console.log("   Generating proofs with compute_proofs_v2...");
            const proofs = compute_proofs_v2(
                circuit_bytes,
                evaluated_bytes,
                ct,
                gateNum // 1-indexed challenge
            );
            
            // Verify proof structure
            expect(proofs.gate_bytes).to.have.length(64, "Gate bytes should be 64 bytes");
            expect(proofs.values).to.be.an("array");
            expect(proofs.curr_acc).to.have.length(32, "Current accumulator should be 32 bytes");
            expect(proofs.proof1).to.be.an("array");
            expect(proofs.proof2).to.be.an("array");
            expect(proofs.proof3).to.be.an("array");
            expect(proofs.proof_ext).to.be.an("array");
            
            console.log(`   ‚úÖ Proofs generated: ${proofs.values.length} values, proof1 has ${proofs.proof1.length} levels`);
            
            // Convert proofs to contract format
            // For bytes/bytes32, ethers.js expects hex strings or Uint8Array
            const gateBytesArray = new Uint8Array(proofs.gate_bytes);
            const valuesArray = proofs.values.map((v: Uint8Array) => new Uint8Array(v));
            const currAccArray = new Uint8Array(proofs.curr_acc);
            
            // Convert proofs to bytes32[][] format (hex strings)
            const proof1Array = proofs.proof1.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            const proof2Array = proofs.proof2.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            const proof3Array = proofs.proof3.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            const proofExtArray = proofs.proof_ext.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            
            // Submit commitment with proofs - should succeed
            console.log("   Submitting commitment with proofs...");
            const tx = await disputeAccount.connect(vendor).submitCommitment(
                commitment.o,
                gateNum,
                gateBytesArray,
                valuesArray,
                currAccArray,
                proof1Array,
                proof2Array,
                proof3Array,
                proofExtArray
            );
            
            const receipt = await tx.wait();
            console.log(`   ‚úÖ Transaction successful! Gas used: ${receipt!.gasUsed.toString()}`);
            
            // Verify state transition
            const newState = Number(await disputeAccount.currState());
            expect(newState).to.equal(0, "Should return to ChallengeBuyer state after successful submission");
        });
    });
    
    describe("Scenario 2: submitCommitmentLeft (Step 8b) - First Gate", function () {
        it("Should generate correct proofs and verify them in submitCommitmentLeft", async function () {
            console.log("\nüìä Scenario 2: submitCommitmentLeft (State 3)");
            
            // Deploy a fresh dispute contract for this scenario
            const { disputeAccount: freshDisputeAccount } = await deployFreshDispute();
            
            // Navigate to state 3 (WaitVendorDataLeft) by making buyer respond incorrectly
            // and vendor always disagreeing until we reach chall == 1
            let state = Number(await freshDisputeAccount.currState());
            const maxRounds = Math.ceil(Math.log2(numGates)) + 5;
            let roundCount = 0;
            
            // Navigate to WaitVendorDataLeft state (chall == 1)
            while (state === 0 && roundCount < maxRounds) {
                const challenge = await freshDisputeAccount.chall();
                console.log(`   Round ${roundCount + 1}: challenge = ${challenge} (1-indexed)`);
                
                // Buyer responds with wrong hpre (ZeroHash)
                await freshDisputeAccount.connect(buyer).respondChallenge(ZeroHash);
                
                // Vendor always disagrees to narrow down to the leftmost gate
                await freshDisputeAccount.connect(vendor).giveOpinion(false);
                
                state = Number(await freshDisputeAccount.currState());
                roundCount++;
                
                if (state === 3) { // WaitVendorDataLeft
                    break;
                }
            }
            
            // If we didn't reach WaitVendorDataLeft, check if chall == 1
            if (state !== 3) {
                const chall = Number(await disputeAccount.chall());
                if (chall === 1) {
                    // Force state transition by having vendor give opinion
                    await disputeAccount.connect(vendor).giveOpinion(false);
                    state = Number(await disputeAccount.currState());
                }
            }
            
            if (state !== 3) {
                console.log(`   ‚ö†Ô∏è  Could not reach WaitVendorDataLeft state (current: ${state}). Skipping test.`);
                this.skip();
                return;
            }
            
            console.log(`   ‚úÖ Reached WaitVendorDataLeft state after ${roundCount} rounds`);
            
            const gateNum = Number(await disputeAccount.a());
            expect(gateNum).to.equal(1, "Gate number should be 1 for submitCommitmentLeft");
            console.log(`   Gate number (challenge): ${gateNum} (1-indexed)`);
            
            // Generate proofs using WASM
            console.log("   Generating proofs with compute_proofs_left_v2...");
            const proofs = compute_proofs_left_v2(
                circuit_bytes,
                evaluated_bytes,
                ct,
                gateNum // 1-indexed challenge
            );
            
            // Verify proof structure
            expect(proofs.gate_bytes).to.have.length(64, "Gate bytes should be 64 bytes");
            expect(proofs.values).to.be.an("array");
            expect(proofs.curr_acc).to.have.length(32, "Current accumulator should be 32 bytes");
            expect(proofs.proof1).to.be.an("array");
            expect(proofs.proof2).to.be.an("array");
            expect(proofs.proof_ext).to.be.an("array");
            
            console.log(`   ‚úÖ Proofs generated: ${proofs.values.length} values`);
            
            // Convert proofs to contract format
            // For bytes/bytes32, ethers.js expects hex strings or Uint8Array
            const gateBytesArray = new Uint8Array(proofs.gate_bytes);
            const valuesArray = proofs.values.map((v: Uint8Array) => new Uint8Array(v));
            const currAccArray = new Uint8Array(proofs.curr_acc);
            
            // Convert proofs to bytes32[][] format (hex strings)
            const proof1Array = proofs.proof1.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            const proof2Array = proofs.proof2.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            const proofExtArray = proofs.proof_ext.map((level: Uint8Array[]) => 
                level.map((v: Uint8Array) => ethers.hexlify(new Uint8Array(v)))
            );
            
            // TEST: Verify that testVerifyCommitmentLeft returns true with WASM-calculated proofs
            console.log("   Testing testVerifyCommitmentLeft with WASM-calculated proofs...");
            const verifyResult = await freshDisputeAccount.testVerifyCommitmentLeft(
                commitment.o,
                gateNum,
                gateBytesArray,
                valuesArray,
                currAccArray,
                proof1Array,
                proof2Array,
                proofExtArray
            );
            
            // If it fails, test step by step to see which verification fails
            if (!verifyResult) {
                console.log("   ‚ö†Ô∏è  testVerifyCommitmentLeft returned false, testing step by step...");
                const stepResults = await freshDisputeAccount.testVerifyCommitmentLeftStepByStep(
                    commitment.o,
                    gateNum,
                    gateBytesArray,
                    valuesArray,
                    currAccArray,
                    proof1Array,
                    proof2Array,
                    proofExtArray
                );
                console.log(`   üìä R√©sultats d√©taill√©s:`);
                console.log(`      - Overall: ${stepResults[0]}`);
                console.log(`      - proof1: ${stepResults[1]}`);
                console.log(`      - proof2: ${stepResults[2]}`);
                console.log(`      - proofExt: ${stepResults[3]}`);
                
                if (!stepResults[1]) {
                    console.log(`   ‚ùå proof1 verification √©choue!`);
                }
                if (!stepResults[2]) {
                    console.log(`   ‚ùå proof2 verification √©choue!`);
                }
                if (!stepResults[3]) {
                    console.log(`   ‚ùå proofExt verification √©choue!`);
                }
            }
            
            expect(verifyResult).to.equal(true, "testVerifyCommitmentLeft should return true with WASM-calculated proofs");
            console.log(`   ‚úÖ‚úÖ‚úÖ testVerifyCommitmentLeft returned: ${verifyResult}`);
            console.log(`   ‚úÖ‚úÖ‚úÖ CONFIRMATION: Les preuves calcul√©es par WASM sont accept√©es par verifyCommitmentLeft!`);
            
            // Submit commitment with proofs - should succeed
            console.log("   Submitting commitment with proofs...");
            const tx = await freshDisputeAccount.connect(vendor).submitCommitmentLeft(
                commitment.o,
                gateNum,
                gateBytesArray,
                valuesArray,
                currAccArray,
                proof1Array,
                proof2Array,
                proofExtArray
            );
            
            const receipt = await tx.wait();
            console.log(`   ‚úÖ Transaction successful! Gas used: ${receipt!.gasUsed.toString()}`);
            
            // Verify state transition
            const newState = Number(await freshDisputeAccount.currState());
            expect(newState).to.equal(0, "Should return to ChallengeBuyer state after successful submission");
        });
    });
    
    describe("Scenario 3: submitCommitmentRight (Step 8c) - Last Gate", function () {
        it("Should generate correct proofs and verify them in submitCommitmentRight", async function () {
            console.log("\nüìä Scenario 3: submitCommitmentRight (State 4)");
            
            // Navigate to state 4 (WaitVendorDataRight) by making buyer respond incorrectly
            // and vendor always agreeing until we reach chall == numGates + 1
            let state = Number(await disputeAccount.currState());
            const maxRounds = Math.ceil(Math.log2(numGates)) + 5;
            let roundCount = 0;
            
            // Navigate to WaitVendorDataRight state (chall == numGates + 1)
            while (state === 0 && roundCount < maxRounds) {
                const challenge = await disputeAccount.chall();
                console.log(`   Round ${roundCount + 1}: challenge = ${challenge} (1-indexed)`);
                
                // Buyer responds with wrong hpre (ZeroHash)
                await disputeAccount.connect(buyer).respondChallenge(ZeroHash);
                
                // Vendor always agrees to narrow down to the rightmost gate
                await disputeAccount.connect(vendor).giveOpinion(true);
                
                state = Number(await disputeAccount.currState());
                roundCount++;
                
                if (state === 4) { // WaitVendorDataRight
                    break;
                }
            }
            
            if (state !== 4) {
                console.log(`   ‚ö†Ô∏è  Could not reach WaitVendorDataRight state (current: ${state}). Skipping test.`);
                this.skip();
                return;
            }
            
            console.log(`   ‚úÖ Reached WaitVendorDataRight state after ${roundCount} rounds`);
            
            const gateNum = Number(await disputeAccount.a());
            expect(gateNum).to.equal(numGates + 1, "Gate number should be numGates + 1 for submitCommitmentRight");
            console.log(`   Gate number (challenge): ${gateNum} (1-indexed, numGates + 1)`);
            
            // Generate proof using WASM
            // For Step 8c, compute_proof_right_v2 takes evaluated_circuit_bytes, num_blocks, num_gates
            // and returns just the proof (Array)
            console.log("   Generating proof with compute_proof_right_v2...");
            const proof = compute_proof_right_v2(
                evaluated_bytes,
                numBlocks,
                numGates
            );
            
            // Verify proof structure
            expect(proof).to.be.an("array", "Proof should be an array");
            expect(proof.length).to.be.greaterThan(0, "Proof should have at least one level");
            
            console.log(`   ‚úÖ Proof generated: ${proof.length} levels`);
            
            // Convert proof to contract format (bytes32[][])
            const proofBytes32: string[][] = [];
            for (let layer = 0; layer < proof.length; layer++) {
                const layerArray: string[] = [];
                for (let item = 0; item < proof[layer].length; item++) {
                    const itemBytes = new Uint8Array(proof[layer][item]);
                    // Ensure it's exactly 32 bytes
                    if (itemBytes.length !== 32) {
                        throw new Error(`Proof item length is ${itemBytes.length}, expected 32`);
                    }
                    layerArray.push(ethers.hexlify(itemBytes));
                }
                proofBytes32.push(layerArray);
            }
            
            // Submit commitment with proof - should succeed
            // submitCommitmentRight only takes the proof parameter
            console.log("   Submitting commitment with proof...");
            const tx = await disputeAccount.connect(vendor).submitCommitmentRight(proofBytes32);
            
            const receipt = await tx.wait();
            console.log(`   ‚úÖ Transaction successful! Gas used: ${receipt!.gasUsed.toString()}`);
            
            // Verify state transition
            const newState = Number(await disputeAccount.currState());
            expect(newState).to.equal(0, "Should return to ChallengeBuyer state after successful submission");
        });
    });
    
    describe("Proof Generation Validation", function () {
        it("Should verify that hpre_v2 generates correct accumulator for different challenges", async function () {
            console.log("\nüîç Testing hpre_v2 correctness...");
            
            // Test hpre_v2 for different challenge values
            for (let challenge = 1; challenge <= Math.min(10, numGates); challenge++) {
                const hpreResult = hpre_v2(evaluated_bytes, numBlocks, challenge);
                
                expect(hpreResult).to.have.length(32, `hpre_v2 result should be 32 bytes for challenge ${challenge}`);
                
                // Verify it's not all zeros
                const isNonZero = hpreResult.some((b: number) => b !== 0);
                expect(isNonZero).to.equal(true, `hpre_v2 result should be non-zero for challenge ${challenge}`);
                
                console.log(`   ‚úÖ Challenge ${challenge}: hpre_v2 returns valid 32-byte accumulator`);
            }
        });
        
        it("Should verify that proof ranges are consistent", async function () {
            console.log("\nüîç Testing proof range consistency...");
            
            // Test for a middle gate
            const challenge = Math.floor(numGates / 2) + 1;
            console.log(`   Testing challenge ${challenge} (1-indexed)`);
            
            const proofs = compute_proofs_v2(
                circuit_bytes,
                evaluated_bytes,
                ct,
                challenge
            );
            
            // Verify that proof_ext uses the same range as curr_acc
            // This is critical for verification to succeed
            expect(proofs.curr_acc).to.have.length(32);
            expect(proofs.proof_ext).to.be.an("array");
            
            // Verify gate_bytes is correctly formatted (64 bytes, opcode in first byte)
            expect(proofs.gate_bytes).to.have.length(64);
            expect(proofs.gate_bytes[0]).to.be.greaterThanOrEqual(0);
            expect(proofs.gate_bytes[0]).to.be.lessThanOrEqual(5); // Valid opcodes: 0-5
            
            console.log(`   ‚úÖ Proof structure validated for challenge ${challenge}`);
            console.log(`      - Gate opcode: ${proofs.gate_bytes[0]}`);
            console.log(`      - Values count: ${proofs.values.length}`);
            console.log(`      - Proof1 levels: ${proofs.proof1.length}`);
            console.log(`      - Proof2 levels: ${proofs.proof2.length}`);
            console.log(`      - Proof3 levels: ${proofs.proof3.length}`);
            console.log(`      - ProofExt levels: ${proofs.proof_ext.length}`);
        });
    });
});

